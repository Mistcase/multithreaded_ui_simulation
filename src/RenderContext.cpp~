#include "RenderContext.h"

#include "TraceProfiler.h"

#include <chrono>
#include <thread>

namespace ui {

RenderContainerNode* RenderContext::EnsureContainerNode(NodeId id) {
    auto it = containerIndex_.find(id);
    if (it != containerIndex_.end()) {
        return &renderContainers_[it->second];
    }
    const std::size_t idx = renderContainers_.size();
    renderContainers_.emplace_back();
    containerIndex_[id] = idx;
    return &renderContainers_[idx];
}

RenderTextNode* RenderContext::EnsureTextNode(NodeId id) {
    auto it = textIndex_.find(id);
    if (it != textIndex_.end()) {
        return &renderTexts_[it->second];
    }
    const std::size_t idx = renderTexts_.size();
    renderTexts_.emplace_back();
    textIndex_[id] = idx;
    return &renderTexts_[idx];
}

RenderContainerNode* RenderContext::TryGetContainer(NodeId id) {
    auto it = containerIndex_.find(id);
    return it != containerIndex_.end() ? &renderContainers_[it->second] : nullptr;
}

RenderTextNode* RenderContext::TryGetText(NodeId id) {
    auto it = textIndex_.find(id);
    return it != textIndex_.end() ? &renderTexts_[it->second] : nullptr;
}

ContainerNodeData& RenderContext::AccessContainerData(NodeId id) {
    return changeBuffer_.AccessContainerData(id);
}

TextNodeData& RenderContext::AccessTextData(NodeId id) {
    return changeBuffer_.AccessTextData(id);
}

void RenderContext::Sync() {
    TRACE_SCOPE("RenderContext::Sync");

    auto containerChanges = changeBuffer_.SnapshotContainers();
    auto textChanges = changeBuffer_.SnapshotTexts();

    {
        std::lock_guard<std::mutex> lock(renderMutex_);
        for (auto& c : containerChanges) {
            c.Flush(*this);
        }
        for (auto& t : textChanges) {
            t.Flush(*this);
        }
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(400));
}

void ContainerNodeData::Flush(RenderContext& ctx) {
    RenderContainerNode* r = render ? render : ctx.EnsureContainerNode(id);
    render = r;
    r->x = x;
    r->y = y;
    r->visible = visible;

    r->children.clear();
    r->children.reserve(children.size());
    for (const auto& child : children) {
        RenderChildPtr out;
        out.isText = child.isText;
        out.id = child.id;
        if (child.isText) {
            out.text = ctx.EnsureTextNode(child.id);
        } else {
            out.container = ctx.EnsureContainerNode(child.id);
        }
        r->children.push_back(out);
    }
}

void TextNodeData::Flush(RenderContext& ctx) {
    RenderTextNode* r = render ? render : ctx.EnsureTextNode(id);
    render = r;
    r->x = x;
    r->y = y;
    r->visible = visible;
    r->text = text;
}

} // namespace ui
