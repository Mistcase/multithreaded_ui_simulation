# Ответы на вопросы про NodeId

## 1. Кто и когда генерирует NodeId?

**Ответ:** `NodeIdAllocator` внутри `RenderContext` генерирует NodeId при создании ноды.

**Момент создания:**
- Когда создаётся новая нода (frontend или backend), вызывается `RenderContext::AllocateNodeId()`
- Это происходит **до** создания `TreeNode` объекта

**Пример:**
```cpp
// В Movie или другом месте создания ноды:
NodeId newId = renderContext_.AllocateNodeId();  // Генерация здесь
auto node = std::make_unique<ContainerNode>(newId, renderContext_);
```

**Как работает `NodeIdAllocator`:**
1. Если есть свободные индексы в `freeIndices_` → переиспользует их
2. Иначе → выделяет новый индекс `nextIndex_++`
3. Возвращает `MakeNodeId(index, generations_[index])`

**Освобождение:**
- При `Term()` → `deleted = true` в ChangeBuffer
- В `Sync()` → `nodeIdAllocator_.Free(id)` инкрементирует generation и добавляет индекс в free list

---

## 2. Зачем `& 0xFFFF` в `(currentGen + 1) & 0xFFFF`?

**Ответ:** На самом деле, для `uint16_t` это **избыточно** - переполнение unsigned типов в C++ даёт well-defined wrap-around.

**Поведение без `& 0xFFFF`:**
```cpp
std::uint16_t gen = 65535;  // Максимальное значение uint16_t
gen = gen + 1;  // Переполнение даёт wrap-around: gen становится 0 (well-defined!)
```

**С `& 0xFFFF`:**
```cpp
std::uint16_t gen = 65535;
gen = (gen + 1) & 0xFFFF;  // Тот же результат: 0
```

**Почему `& 0xFFFF` может быть полезен:**
1. **Явность намерения** - показывает, что мы намеренно делаем wrap-around
2. **Защита от изменений типа** - если кто-то изменит тип на `uint32_t`, `& 0xFFFF` всё равно обрежет до 16 бит
3. **Читаемость** - явно показывает, что мы работаем с 16-битным значением

**Но технически:**
- Для `uint16_t` переполнение и так даёт wrap-around автоматически (well-defined behavior)
- `& 0xFFFF` не обязателен, но и не вредит
- Можно убрать, код будет работать так же: `gen = gen + 1;`

---

## 3. Как гарантировать отсутствие "дырок" в векторах?

**Проблема:** После удаления нод могут остаться "дырки" в векторах:
```cpp
renderTexts_ = [node0, node1, node2, node3, node4]
// Удалили node1 и node3
renderTexts_ = [node0, {}, node2, {}, node4]  // Дырки!
```

**Текущее решение:** Дырки допустимы, но есть free list для переиспользования.

**Как это работает:**
1. При удалении ноды индекс добавляется в `freeIndices_`
2. При следующем `Allocate()` переиспользуется индекс из free list
3. Векторы **не сжимаются** (остаются дырки), но индексы переиспользуются

**Проблемы дырок:**
- Память не освобождается (вектор не уменьшается)
- Итерация по всем элементам включает пустые слоты
- Но: прямой доступ по индексу всё равно O(1)

**Решения:**

### Вариант 1: Терпеть дырки (текущий)
- Плюсы: просто, быстро
- Минусы: память не освобождается

### Вариант 2: Compact (периодическое сжатие)
```cpp
void Compact() {
    // Переместить все живые ноды в начало
    // Обновить индексы в handle
    // Сложно и дорого
}
```

### Вариант 3: Гарантировать плотное заполнение
- Всегда переиспользовать индексы из free list
- Никогда не выделять новые индексы пока есть свободные
- Но: всё равно останутся дырки после удаления

**Рекомендация:** 
- Для большинства случаев дырки допустимы
- Если критична память → периодический compact
- Если критична скорость → оставить как есть (O(1) доступ важнее)
